// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v6.33.0
// source: sync/v1/sync.proto

package syncv1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	SyncService_GetServerInfo_FullMethodName = "/toolbridge.sync.v1.SyncService/GetServerInfo"
	SyncService_BeginSession_FullMethodName  = "/toolbridge.sync.v1.SyncService/BeginSession"
	SyncService_EndSession_FullMethodName    = "/toolbridge.sync.v1.SyncService/EndSession"
	SyncService_WipeAccount_FullMethodName   = "/toolbridge.sync.v1.SyncService/WipeAccount"
	SyncService_GetSyncState_FullMethodName  = "/toolbridge.sync.v1.SyncService/GetSyncState"
)

// SyncServiceClient is the client API for SyncService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ===================================================================
// Core Service: Handles sessions, discovery, and account management
// ===================================================================
type SyncServiceClient interface {
	// Get server capabilities (replicates /v1/sync/info)
	GetServerInfo(ctx context.Context, in *GetServerInfoRequest, opts ...grpc.CallOption) (*ServerInfo, error)
	// Start a new sync session (replicates POST /v1/sync/sessions)
	BeginSession(ctx context.Context, in *BeginSessionRequest, opts ...grpc.CallOption) (*SyncSession, error)
	// End a sync session (replicates DELETE /v1/sync/sessions/{id})
	EndSession(ctx context.Context, in *EndSessionRequest, opts ...grpc.CallOption) (*EndSessionResponse, error)
	// Wipe account data (replicates POST /v1/sync/wipe)
	WipeAccount(ctx context.Context, in *WipeAccountRequest, opts ...grpc.CallOption) (*WipeResult, error)
	// Get user sync state (replicates GET /v1/sync/state)
	GetSyncState(ctx context.Context, in *GetSyncStateRequest, opts ...grpc.CallOption) (*UserSyncState, error)
}

type syncServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSyncServiceClient(cc grpc.ClientConnInterface) SyncServiceClient {
	return &syncServiceClient{cc}
}

func (c *syncServiceClient) GetServerInfo(ctx context.Context, in *GetServerInfoRequest, opts ...grpc.CallOption) (*ServerInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ServerInfo)
	err := c.cc.Invoke(ctx, SyncService_GetServerInfo_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncServiceClient) BeginSession(ctx context.Context, in *BeginSessionRequest, opts ...grpc.CallOption) (*SyncSession, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SyncSession)
	err := c.cc.Invoke(ctx, SyncService_BeginSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncServiceClient) EndSession(ctx context.Context, in *EndSessionRequest, opts ...grpc.CallOption) (*EndSessionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(EndSessionResponse)
	err := c.cc.Invoke(ctx, SyncService_EndSession_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncServiceClient) WipeAccount(ctx context.Context, in *WipeAccountRequest, opts ...grpc.CallOption) (*WipeResult, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WipeResult)
	err := c.cc.Invoke(ctx, SyncService_WipeAccount_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *syncServiceClient) GetSyncState(ctx context.Context, in *GetSyncStateRequest, opts ...grpc.CallOption) (*UserSyncState, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UserSyncState)
	err := c.cc.Invoke(ctx, SyncService_GetSyncState_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SyncServiceServer is the server API for SyncService service.
// All implementations must embed UnimplementedSyncServiceServer
// for forward compatibility.
//
// ===================================================================
// Core Service: Handles sessions, discovery, and account management
// ===================================================================
type SyncServiceServer interface {
	// Get server capabilities (replicates /v1/sync/info)
	GetServerInfo(context.Context, *GetServerInfoRequest) (*ServerInfo, error)
	// Start a new sync session (replicates POST /v1/sync/sessions)
	BeginSession(context.Context, *BeginSessionRequest) (*SyncSession, error)
	// End a sync session (replicates DELETE /v1/sync/sessions/{id})
	EndSession(context.Context, *EndSessionRequest) (*EndSessionResponse, error)
	// Wipe account data (replicates POST /v1/sync/wipe)
	WipeAccount(context.Context, *WipeAccountRequest) (*WipeResult, error)
	// Get user sync state (replicates GET /v1/sync/state)
	GetSyncState(context.Context, *GetSyncStateRequest) (*UserSyncState, error)
	mustEmbedUnimplementedSyncServiceServer()
}

// UnimplementedSyncServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSyncServiceServer struct{}

func (UnimplementedSyncServiceServer) GetServerInfo(context.Context, *GetServerInfoRequest) (*ServerInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetServerInfo not implemented")
}
func (UnimplementedSyncServiceServer) BeginSession(context.Context, *BeginSessionRequest) (*SyncSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BeginSession not implemented")
}
func (UnimplementedSyncServiceServer) EndSession(context.Context, *EndSessionRequest) (*EndSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EndSession not implemented")
}
func (UnimplementedSyncServiceServer) WipeAccount(context.Context, *WipeAccountRequest) (*WipeResult, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WipeAccount not implemented")
}
func (UnimplementedSyncServiceServer) GetSyncState(context.Context, *GetSyncStateRequest) (*UserSyncState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSyncState not implemented")
}
func (UnimplementedSyncServiceServer) mustEmbedUnimplementedSyncServiceServer() {}
func (UnimplementedSyncServiceServer) testEmbeddedByValue()                     {}

// UnsafeSyncServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SyncServiceServer will
// result in compilation errors.
type UnsafeSyncServiceServer interface {
	mustEmbedUnimplementedSyncServiceServer()
}

func RegisterSyncServiceServer(s grpc.ServiceRegistrar, srv SyncServiceServer) {
	// If the following call pancis, it indicates UnimplementedSyncServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SyncService_ServiceDesc, srv)
}

func _SyncService_GetServerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncServiceServer).GetServerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SyncService_GetServerInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncServiceServer).GetServerInfo(ctx, req.(*GetServerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncService_BeginSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BeginSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncServiceServer).BeginSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SyncService_BeginSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncServiceServer).BeginSession(ctx, req.(*BeginSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncService_EndSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EndSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncServiceServer).EndSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SyncService_EndSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncServiceServer).EndSession(ctx, req.(*EndSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncService_WipeAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WipeAccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncServiceServer).WipeAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SyncService_WipeAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncServiceServer).WipeAccount(ctx, req.(*WipeAccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SyncService_GetSyncState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSyncStateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SyncServiceServer).GetSyncState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SyncService_GetSyncState_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SyncServiceServer).GetSyncState(ctx, req.(*GetSyncStateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SyncService_ServiceDesc is the grpc.ServiceDesc for SyncService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SyncService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "toolbridge.sync.v1.SyncService",
	HandlerType: (*SyncServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetServerInfo",
			Handler:    _SyncService_GetServerInfo_Handler,
		},
		{
			MethodName: "BeginSession",
			Handler:    _SyncService_BeginSession_Handler,
		},
		{
			MethodName: "EndSession",
			Handler:    _SyncService_EndSession_Handler,
		},
		{
			MethodName: "WipeAccount",
			Handler:    _SyncService_WipeAccount_Handler,
		},
		{
			MethodName: "GetSyncState",
			Handler:    _SyncService_GetSyncState_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sync/v1/sync.proto",
}

const (
	NoteSyncService_Push_FullMethodName = "/toolbridge.sync.v1.NoteSyncService/Push"
	NoteSyncService_Pull_FullMethodName = "/toolbridge.sync.v1.NoteSyncService/Pull"
)

// NoteSyncServiceClient is the client API for NoteSyncService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NoteSyncServiceClient interface {
	Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error)
	Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error)
}

type noteSyncServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNoteSyncServiceClient(cc grpc.ClientConnInterface) NoteSyncServiceClient {
	return &noteSyncServiceClient{cc}
}

func (c *noteSyncServiceClient) Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, NoteSyncService_Push_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *noteSyncServiceClient) Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PullResponse)
	err := c.cc.Invoke(ctx, NoteSyncService_Pull_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NoteSyncServiceServer is the server API for NoteSyncService service.
// All implementations must embed UnimplementedNoteSyncServiceServer
// for forward compatibility.
type NoteSyncServiceServer interface {
	Push(context.Context, *PushRequest) (*PushResponse, error)
	Pull(context.Context, *PullRequest) (*PullResponse, error)
	mustEmbedUnimplementedNoteSyncServiceServer()
}

// UnimplementedNoteSyncServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNoteSyncServiceServer struct{}

func (UnimplementedNoteSyncServiceServer) Push(context.Context, *PushRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Push not implemented")
}
func (UnimplementedNoteSyncServiceServer) Pull(context.Context, *PullRequest) (*PullResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pull not implemented")
}
func (UnimplementedNoteSyncServiceServer) mustEmbedUnimplementedNoteSyncServiceServer() {}
func (UnimplementedNoteSyncServiceServer) testEmbeddedByValue()                         {}

// UnsafeNoteSyncServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NoteSyncServiceServer will
// result in compilation errors.
type UnsafeNoteSyncServiceServer interface {
	mustEmbedUnimplementedNoteSyncServiceServer()
}

func RegisterNoteSyncServiceServer(s grpc.ServiceRegistrar, srv NoteSyncServiceServer) {
	// If the following call pancis, it indicates UnimplementedNoteSyncServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NoteSyncService_ServiceDesc, srv)
}

func _NoteSyncService_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteSyncServiceServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NoteSyncService_Push_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteSyncServiceServer).Push(ctx, req.(*PushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NoteSyncService_Pull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NoteSyncServiceServer).Pull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NoteSyncService_Pull_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NoteSyncServiceServer).Pull(ctx, req.(*PullRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NoteSyncService_ServiceDesc is the grpc.ServiceDesc for NoteSyncService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NoteSyncService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "toolbridge.sync.v1.NoteSyncService",
	HandlerType: (*NoteSyncServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Push",
			Handler:    _NoteSyncService_Push_Handler,
		},
		{
			MethodName: "Pull",
			Handler:    _NoteSyncService_Pull_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sync/v1/sync.proto",
}

const (
	TaskSyncService_Push_FullMethodName = "/toolbridge.sync.v1.TaskSyncService/Push"
	TaskSyncService_Pull_FullMethodName = "/toolbridge.sync.v1.TaskSyncService/Pull"
)

// TaskSyncServiceClient is the client API for TaskSyncService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TaskSyncServiceClient interface {
	Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error)
	Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error)
}

type taskSyncServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTaskSyncServiceClient(cc grpc.ClientConnInterface) TaskSyncServiceClient {
	return &taskSyncServiceClient{cc}
}

func (c *taskSyncServiceClient) Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, TaskSyncService_Push_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *taskSyncServiceClient) Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PullResponse)
	err := c.cc.Invoke(ctx, TaskSyncService_Pull_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TaskSyncServiceServer is the server API for TaskSyncService service.
// All implementations must embed UnimplementedTaskSyncServiceServer
// for forward compatibility.
type TaskSyncServiceServer interface {
	Push(context.Context, *PushRequest) (*PushResponse, error)
	Pull(context.Context, *PullRequest) (*PullResponse, error)
	mustEmbedUnimplementedTaskSyncServiceServer()
}

// UnimplementedTaskSyncServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTaskSyncServiceServer struct{}

func (UnimplementedTaskSyncServiceServer) Push(context.Context, *PushRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Push not implemented")
}
func (UnimplementedTaskSyncServiceServer) Pull(context.Context, *PullRequest) (*PullResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pull not implemented")
}
func (UnimplementedTaskSyncServiceServer) mustEmbedUnimplementedTaskSyncServiceServer() {}
func (UnimplementedTaskSyncServiceServer) testEmbeddedByValue()                         {}

// UnsafeTaskSyncServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TaskSyncServiceServer will
// result in compilation errors.
type UnsafeTaskSyncServiceServer interface {
	mustEmbedUnimplementedTaskSyncServiceServer()
}

func RegisterTaskSyncServiceServer(s grpc.ServiceRegistrar, srv TaskSyncServiceServer) {
	// If the following call pancis, it indicates UnimplementedTaskSyncServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TaskSyncService_ServiceDesc, srv)
}

func _TaskSyncService_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskSyncServiceServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskSyncService_Push_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskSyncServiceServer).Push(ctx, req.(*PushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TaskSyncService_Pull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TaskSyncServiceServer).Pull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TaskSyncService_Pull_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TaskSyncServiceServer).Pull(ctx, req.(*PullRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TaskSyncService_ServiceDesc is the grpc.ServiceDesc for TaskSyncService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TaskSyncService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "toolbridge.sync.v1.TaskSyncService",
	HandlerType: (*TaskSyncServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Push",
			Handler:    _TaskSyncService_Push_Handler,
		},
		{
			MethodName: "Pull",
			Handler:    _TaskSyncService_Pull_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sync/v1/sync.proto",
}

const (
	CommentSyncService_Push_FullMethodName = "/toolbridge.sync.v1.CommentSyncService/Push"
	CommentSyncService_Pull_FullMethodName = "/toolbridge.sync.v1.CommentSyncService/Pull"
)

// CommentSyncServiceClient is the client API for CommentSyncService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CommentSyncServiceClient interface {
	Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error)
	Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error)
}

type commentSyncServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCommentSyncServiceClient(cc grpc.ClientConnInterface) CommentSyncServiceClient {
	return &commentSyncServiceClient{cc}
}

func (c *commentSyncServiceClient) Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, CommentSyncService_Push_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *commentSyncServiceClient) Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PullResponse)
	err := c.cc.Invoke(ctx, CommentSyncService_Pull_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CommentSyncServiceServer is the server API for CommentSyncService service.
// All implementations must embed UnimplementedCommentSyncServiceServer
// for forward compatibility.
type CommentSyncServiceServer interface {
	Push(context.Context, *PushRequest) (*PushResponse, error)
	Pull(context.Context, *PullRequest) (*PullResponse, error)
	mustEmbedUnimplementedCommentSyncServiceServer()
}

// UnimplementedCommentSyncServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCommentSyncServiceServer struct{}

func (UnimplementedCommentSyncServiceServer) Push(context.Context, *PushRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Push not implemented")
}
func (UnimplementedCommentSyncServiceServer) Pull(context.Context, *PullRequest) (*PullResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pull not implemented")
}
func (UnimplementedCommentSyncServiceServer) mustEmbedUnimplementedCommentSyncServiceServer() {}
func (UnimplementedCommentSyncServiceServer) testEmbeddedByValue()                            {}

// UnsafeCommentSyncServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CommentSyncServiceServer will
// result in compilation errors.
type UnsafeCommentSyncServiceServer interface {
	mustEmbedUnimplementedCommentSyncServiceServer()
}

func RegisterCommentSyncServiceServer(s grpc.ServiceRegistrar, srv CommentSyncServiceServer) {
	// If the following call pancis, it indicates UnimplementedCommentSyncServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CommentSyncService_ServiceDesc, srv)
}

func _CommentSyncService_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentSyncServiceServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentSyncService_Push_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentSyncServiceServer).Push(ctx, req.(*PushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CommentSyncService_Pull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CommentSyncServiceServer).Pull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CommentSyncService_Pull_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CommentSyncServiceServer).Pull(ctx, req.(*PullRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CommentSyncService_ServiceDesc is the grpc.ServiceDesc for CommentSyncService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CommentSyncService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "toolbridge.sync.v1.CommentSyncService",
	HandlerType: (*CommentSyncServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Push",
			Handler:    _CommentSyncService_Push_Handler,
		},
		{
			MethodName: "Pull",
			Handler:    _CommentSyncService_Pull_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sync/v1/sync.proto",
}

const (
	ChatSyncService_Push_FullMethodName = "/toolbridge.sync.v1.ChatSyncService/Push"
	ChatSyncService_Pull_FullMethodName = "/toolbridge.sync.v1.ChatSyncService/Pull"
)

// ChatSyncServiceClient is the client API for ChatSyncService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChatSyncServiceClient interface {
	Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error)
	Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error)
}

type chatSyncServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChatSyncServiceClient(cc grpc.ClientConnInterface) ChatSyncServiceClient {
	return &chatSyncServiceClient{cc}
}

func (c *chatSyncServiceClient) Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, ChatSyncService_Push_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatSyncServiceClient) Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PullResponse)
	err := c.cc.Invoke(ctx, ChatSyncService_Pull_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChatSyncServiceServer is the server API for ChatSyncService service.
// All implementations must embed UnimplementedChatSyncServiceServer
// for forward compatibility.
type ChatSyncServiceServer interface {
	Push(context.Context, *PushRequest) (*PushResponse, error)
	Pull(context.Context, *PullRequest) (*PullResponse, error)
	mustEmbedUnimplementedChatSyncServiceServer()
}

// UnimplementedChatSyncServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChatSyncServiceServer struct{}

func (UnimplementedChatSyncServiceServer) Push(context.Context, *PushRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Push not implemented")
}
func (UnimplementedChatSyncServiceServer) Pull(context.Context, *PullRequest) (*PullResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pull not implemented")
}
func (UnimplementedChatSyncServiceServer) mustEmbedUnimplementedChatSyncServiceServer() {}
func (UnimplementedChatSyncServiceServer) testEmbeddedByValue()                         {}

// UnsafeChatSyncServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatSyncServiceServer will
// result in compilation errors.
type UnsafeChatSyncServiceServer interface {
	mustEmbedUnimplementedChatSyncServiceServer()
}

func RegisterChatSyncServiceServer(s grpc.ServiceRegistrar, srv ChatSyncServiceServer) {
	// If the following call pancis, it indicates UnimplementedChatSyncServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChatSyncService_ServiceDesc, srv)
}

func _ChatSyncService_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatSyncServiceServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatSyncService_Push_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatSyncServiceServer).Push(ctx, req.(*PushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatSyncService_Pull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatSyncServiceServer).Pull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatSyncService_Pull_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatSyncServiceServer).Pull(ctx, req.(*PullRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChatSyncService_ServiceDesc is the grpc.ServiceDesc for ChatSyncService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatSyncService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "toolbridge.sync.v1.ChatSyncService",
	HandlerType: (*ChatSyncServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Push",
			Handler:    _ChatSyncService_Push_Handler,
		},
		{
			MethodName: "Pull",
			Handler:    _ChatSyncService_Pull_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sync/v1/sync.proto",
}

const (
	ChatMessageSyncService_Push_FullMethodName = "/toolbridge.sync.v1.ChatMessageSyncService/Push"
	ChatMessageSyncService_Pull_FullMethodName = "/toolbridge.sync.v1.ChatMessageSyncService/Pull"
)

// ChatMessageSyncServiceClient is the client API for ChatMessageSyncService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ChatMessageSyncServiceClient interface {
	Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error)
	Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error)
}

type chatMessageSyncServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChatMessageSyncServiceClient(cc grpc.ClientConnInterface) ChatMessageSyncServiceClient {
	return &chatMessageSyncServiceClient{cc}
}

func (c *chatMessageSyncServiceClient) Push(ctx context.Context, in *PushRequest, opts ...grpc.CallOption) (*PushResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PushResponse)
	err := c.cc.Invoke(ctx, ChatMessageSyncService_Push_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatMessageSyncServiceClient) Pull(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PullResponse)
	err := c.cc.Invoke(ctx, ChatMessageSyncService_Pull_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChatMessageSyncServiceServer is the server API for ChatMessageSyncService service.
// All implementations must embed UnimplementedChatMessageSyncServiceServer
// for forward compatibility.
type ChatMessageSyncServiceServer interface {
	Push(context.Context, *PushRequest) (*PushResponse, error)
	Pull(context.Context, *PullRequest) (*PullResponse, error)
	mustEmbedUnimplementedChatMessageSyncServiceServer()
}

// UnimplementedChatMessageSyncServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChatMessageSyncServiceServer struct{}

func (UnimplementedChatMessageSyncServiceServer) Push(context.Context, *PushRequest) (*PushResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Push not implemented")
}
func (UnimplementedChatMessageSyncServiceServer) Pull(context.Context, *PullRequest) (*PullResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Pull not implemented")
}
func (UnimplementedChatMessageSyncServiceServer) mustEmbedUnimplementedChatMessageSyncServiceServer() {
}
func (UnimplementedChatMessageSyncServiceServer) testEmbeddedByValue() {}

// UnsafeChatMessageSyncServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatMessageSyncServiceServer will
// result in compilation errors.
type UnsafeChatMessageSyncServiceServer interface {
	mustEmbedUnimplementedChatMessageSyncServiceServer()
}

func RegisterChatMessageSyncServiceServer(s grpc.ServiceRegistrar, srv ChatMessageSyncServiceServer) {
	// If the following call pancis, it indicates UnimplementedChatMessageSyncServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChatMessageSyncService_ServiceDesc, srv)
}

func _ChatMessageSyncService_Push_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PushRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatMessageSyncServiceServer).Push(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatMessageSyncService_Push_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatMessageSyncServiceServer).Push(ctx, req.(*PushRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatMessageSyncService_Pull_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatMessageSyncServiceServer).Pull(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatMessageSyncService_Pull_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatMessageSyncServiceServer).Pull(ctx, req.(*PullRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ChatMessageSyncService_ServiceDesc is the grpc.ServiceDesc for ChatMessageSyncService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatMessageSyncService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "toolbridge.sync.v1.ChatMessageSyncService",
	HandlerType: (*ChatMessageSyncServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Push",
			Handler:    _ChatMessageSyncService_Push_Handler,
		},
		{
			MethodName: "Pull",
			Handler:    _ChatMessageSyncService_Pull_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sync/v1/sync.proto",
}
